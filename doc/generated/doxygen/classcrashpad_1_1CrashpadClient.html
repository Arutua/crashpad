<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Crashpad: crashpad::CrashpadClient Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="crashpad_doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Crashpad
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecrashpad.html">crashpad</a></li><li class="navelem"><a class="el" href="classcrashpad_1_1CrashpadClient.html">CrashpadClient</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classcrashpad_1_1CrashpadClient-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">crashpad::CrashpadClient Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The primary interface for an application to have Crashpad monitor it for crashes.  
 <a href="classcrashpad_1_1CrashpadClient.html#details">More...</a></p>

<p><code>#include &quot;client/crashpad_client.h&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae46278158517f37dab44a72652dfd20c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: uint32_t </td></tr>
<tr class="separator:ae46278158517f37dab44a72652dfd20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a810ad9941bedba543bf60507c31c55da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1CrashpadClient.html#a810ad9941bedba543bf60507c31c55da">StartHandler</a> (const base::FilePath &amp;handler, const base::FilePath &amp;database, const base::FilePath &amp;metrics_dir, const std::string &amp;url, const std::map&lt; std::string, std::string &gt; &amp;annotations, const std::vector&lt; std::string &gt; &amp;arguments, bool restartable, bool asynchronous_start)</td></tr>
<tr class="memdesc:a810ad9941bedba543bf60507c31c55da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a Crashpad handler process, performing any necessary handshake to configure it.  <a href="#a810ad9941bedba543bf60507c31c55da">More...</a><br /></td></tr>
<tr class="separator:a810ad9941bedba543bf60507c31c55da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f34445eca859e6c0d1876e8e171c25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1CrashpadClient.html#a89f34445eca859e6c0d1876e8e171c25">SetHandlerMachService</a> (const std::string &amp;service_name)</td></tr>
<tr class="memdesc:a89f34445eca859e6c0d1876e8e171c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the process’ crash handler to a Mach service registered with the bootstrap server.  <a href="#a89f34445eca859e6c0d1876e8e171c25">More...</a><br /></td></tr>
<tr class="separator:a89f34445eca859e6c0d1876e8e171c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e9ce1b1771a597aa3276ec28de28a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1CrashpadClient.html#a35e9ce1b1771a597aa3276ec28de28a7">SetHandlerMachPort</a> (base::mac::ScopedMachSendRight exception_port)</td></tr>
<tr class="memdesc:a35e9ce1b1771a597aa3276ec28de28a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the process’ crash handler to a Mach port.  <a href="#a35e9ce1b1771a597aa3276ec28de28a7">More...</a><br /></td></tr>
<tr class="separator:a35e9ce1b1771a597aa3276ec28de28a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1d5d38e9b4f5781e3821551dcc39d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1CrashpadClient.html#a9f1d5d38e9b4f5781e3821551dcc39d5">SetHandlerIPCPipe</a> (const std::wstring &amp;ipc_pipe)</td></tr>
<tr class="memdesc:a9f1d5d38e9b4f5781e3821551dcc39d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the IPC pipe of a presumably-running Crashpad handler process which was started with <a class="el" href="classcrashpad_1_1CrashpadClient.html#a810ad9941bedba543bf60507c31c55da" title="Starts a Crashpad handler process, performing any necessary handshake to configure it...">StartHandler()</a> or by other compatible means and does an IPC message exchange to register this process with the handler. Crashes will be serviced once this method returns.  <a href="#a9f1d5d38e9b4f5781e3821551dcc39d5">More...</a><br /></td></tr>
<tr class="separator:a9f1d5d38e9b4f5781e3821551dcc39d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc86d3d5bc6dcc9c9456e487f516c4d"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1CrashpadClient.html#a2fc86d3d5bc6dcc9c9456e487f516c4d">GetHandlerIPCPipe</a> () const</td></tr>
<tr class="memdesc:a2fc86d3d5bc6dcc9c9456e487f516c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the IPC pipe name used to register with the Crashpad handler.  <a href="#a2fc86d3d5bc6dcc9c9456e487f516c4d">More...</a><br /></td></tr>
<tr class="separator:a2fc86d3d5bc6dcc9c9456e487f516c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0377d4e93ac77453f57f3c1fcae09e14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1CrashpadClient.html#a0377d4e93ac77453f57f3c1fcae09e14">WaitForHandlerStart</a> (unsigned int timeout_ms)</td></tr>
<tr class="memdesc:a0377d4e93ac77453f57f3c1fcae09e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">When <code>asynchronous_start</code> is used with <a class="el" href="classcrashpad_1_1CrashpadClient.html#a810ad9941bedba543bf60507c31c55da" title="Starts a Crashpad handler process, performing any necessary handshake to configure it...">StartHandler()</a>, this method can be used to block until the handler launch has been completed to retrieve status information.  <a href="#a0377d4e93ac77453f57f3c1fcae09e14">More...</a><br /></td></tr>
<tr class="separator:a0377d4e93ac77453f57f3c1fcae09e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b795ac1d4e01ba03e4085954249edfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1CrashpadClient.html#a0b795ac1d4e01ba03e4085954249edfc">DumpAndCrashTargetProcess</a> (HANDLE process, HANDLE blame_thread, DWORD exception_code) const</td></tr>
<tr class="memdesc:a0b795ac1d4e01ba03e4085954249edfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that the handler capture a dump of a different process.  <a href="#a0b795ac1d4e01ba03e4085954249edfc">More...</a><br /></td></tr>
<tr class="separator:a0b795ac1d4e01ba03e4085954249edfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8ac211aa3a8cf278eb10f4058a7776fb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1CrashpadClient.html#a8ac211aa3a8cf278eb10f4058a7776fb">DumpWithoutCrash</a> (const CONTEXT &amp;context)</td></tr>
<tr class="memdesc:a8ac211aa3a8cf278eb10f4058a7776fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that the handler capture a dump even though there hasn't been a crash.  <a href="#a8ac211aa3a8cf278eb10f4058a7776fb">More...</a><br /></td></tr>
<tr class="separator:a8ac211aa3a8cf278eb10f4058a7776fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d1fa142b0bf7094fc66fef3135a64a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1CrashpadClient.html#a87d1fa142b0bf7094fc66fef3135a64a">DumpAndCrash</a> (EXCEPTION_POINTERS *exception_pointers)</td></tr>
<tr class="memdesc:a87d1fa142b0bf7094fc66fef3135a64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that the handler capture a dump using the given <em>exception_pointers</em> to get the <code>EXCEPTION_RECORD</code> and <code>CONTEXT</code>.  <a href="#a87d1fa142b0bf7094fc66fef3135a64a">More...</a><br /></td></tr>
<tr class="separator:a87d1fa142b0bf7094fc66fef3135a64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6a1e62d90a67db782664b1fe5a952f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrashpad_1_1CrashpadClient.html#a1a6a1e62d90a67db782664b1fe5a952f">UseSystemDefaultHandler</a> ()</td></tr>
<tr class="memdesc:a1a6a1e62d90a67db782664b1fe5a952f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the process to direct its crashes to the default handler for the operating system.  <a href="#a1a6a1e62d90a67db782664b1fe5a952f">More...</a><br /></td></tr>
<tr class="separator:a1a6a1e62d90a67db782664b1fe5a952f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The primary interface for an application to have Crashpad monitor it for crashes. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ae46278158517f37dab44a72652dfd20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46278158517f37dab44a72652dfd20c">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae46278158517f37dab44a72652dfd20ca193286f9cde3032e18a06a4e6452e660"></a>kTriggeredExceptionCode&#160;</td><td class="fielddoc"><p>The exception code (roughly "Client called") used when <a class="el" href="classcrashpad_1_1CrashpadClient.html#a0b795ac1d4e01ba03e4085954249edfc" title="Requests that the handler capture a dump of a different process. ">DumpAndCrashTargetProcess()</a> triggers an exception in a target process. </p>
<dl class="section note"><dt>Note</dt><dd>This value does not have any bits of the top nibble set, to avoid confusion with real exception codes which tend to have those bits set. </dd></dl>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a87d1fa142b0bf7094fc66fef3135a64a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d1fa142b0bf7094fc66fef3135a64a">&#9670;&nbsp;</a></span>DumpAndCrash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::CrashpadClient::DumpAndCrash </td>
          <td>(</td>
          <td class="paramtype">EXCEPTION_POINTERS *&#160;</td>
          <td class="paramname"><em>exception_pointers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests that the handler capture a dump using the given <em>exception_pointers</em> to get the <code>EXCEPTION_RECORD</code> and <code>CONTEXT</code>. </p>
<p>This function is not necessary in general usage as an unhandled exception filter is installed by <a class="el" href="classcrashpad_1_1CrashpadClient.html#a810ad9941bedba543bf60507c31c55da" title="Starts a Crashpad handler process, performing any necessary handshake to configure it...">StartHandler()</a> or <a class="el" href="classcrashpad_1_1CrashpadClient.html#a9f1d5d38e9b4f5781e3821551dcc39d5" title="Sets the IPC pipe of a presumably-running Crashpad handler process which was started with StartHandle...">SetHandlerIPCPipe()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">exception_pointers</td><td>An <code>EXCEPTION_POINTERS</code>, as would generally passed to an unhandled exception filter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b795ac1d4e01ba03e4085954249edfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b795ac1d4e01ba03e4085954249edfc">&#9670;&nbsp;</a></span>DumpAndCrashTargetProcess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::CrashpadClient::DumpAndCrashTargetProcess </td>
          <td>(</td>
          <td class="paramtype">HANDLE&#160;</td>
          <td class="paramname"><em>process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HANDLE&#160;</td>
          <td class="paramname"><em>blame_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>exception_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests that the handler capture a dump of a different process. </p>
<p>The target process must be an already-registered Crashpad client. An exception will be triggered in the target process, and the regular dump mechanism used. This function will block until the exception in the target process has been handled by the Crashpad handler.</p>
<p>This function is unavailable when running on Windows XP and will return <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">process</td><td>A <code>HANDLE</code> identifying the process to be dumped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blame_thread</td><td>If non-null, a <code>HANDLE</code> valid in the caller's process, referring to a thread in the target process. If this is supplied, instead of the exception referring to the location where the exception was injected, an exception record will be fabricated that refers to the current location of the given thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exception_code</td><td>If <em>blame_thread</em> is non-null, this will be used as the exception code in the exception record.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the exception was triggered successfully. </dd></dl>

</div>
</div>
<a id="a8ac211aa3a8cf278eb10f4058a7776fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac211aa3a8cf278eb10f4058a7776fb">&#9670;&nbsp;</a></span>DumpWithoutCrash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::CrashpadClient::DumpWithoutCrash </td>
          <td>(</td>
          <td class="paramtype">const CONTEXT &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests that the handler capture a dump even though there hasn't been a crash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>A <code>CONTEXT</code>, generally captured by <a class="el" href="namespacecrashpad.html#ac25486c6b4c38fc7c7868e978094edcf" title="Saves the CPU context. ">CaptureContext()</a> or similar. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fc86d3d5bc6dcc9c9456e487f516c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc86d3d5bc6dcc9c9456e487f516c4d">&#9670;&nbsp;</a></span>GetHandlerIPCPipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring crashpad::CrashpadClient::GetHandlerIPCPipe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the IPC pipe name used to register with the Crashpad handler. </p>
<p>This method retrieves the IPC pipe name set by <a class="el" href="classcrashpad_1_1CrashpadClient.html#a9f1d5d38e9b4f5781e3821551dcc39d5" title="Sets the IPC pipe of a presumably-running Crashpad handler process which was started with StartHandle...">SetHandlerIPCPipe()</a>, or a suitable IPC pipe name chosen by <a class="el" href="classcrashpad_1_1CrashpadClient.html#a810ad9941bedba543bf60507c31c55da" title="Starts a Crashpad handler process, performing any necessary handshake to configure it...">StartHandler()</a>. It is intended to be used to obtain the IPC pipe name so that it may be passed to other processes, so that they may register with an existing Crashpad handler by calling <a class="el" href="classcrashpad_1_1CrashpadClient.html#a9f1d5d38e9b4f5781e3821551dcc39d5" title="Sets the IPC pipe of a presumably-running Crashpad handler process which was started with StartHandle...">SetHandlerIPCPipe()</a>.</p>
<p>This method is only defined on Windows.</p>
<dl class="section return"><dt>Returns</dt><dd>The full name of the crash handler IPC pipe, a string of the form <code>&quot;\\.\pipe\NAME&quot;</code>. </dd></dl>

</div>
</div>
<a id="a9f1d5d38e9b4f5781e3821551dcc39d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1d5d38e9b4f5781e3821551dcc39d5">&#9670;&nbsp;</a></span>SetHandlerIPCPipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::CrashpadClient::SetHandlerIPCPipe </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>ipc_pipe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the IPC pipe of a presumably-running Crashpad handler process which was started with <a class="el" href="classcrashpad_1_1CrashpadClient.html#a810ad9941bedba543bf60507c31c55da" title="Starts a Crashpad handler process, performing any necessary handshake to configure it...">StartHandler()</a> or by other compatible means and does an IPC message exchange to register this process with the handler. Crashes will be serviced once this method returns. </p>
<p>This method is only defined on Windows.</p>
<p>This method sets the unhandled exception handler to a local function that when reached will "signal and wait" for the crash handler process to create the dump.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ipc_pipe</td><td>The full name of the crash handler IPC pipe. This is a string of the form <code>&quot;\\.\pipe\NAME&quot;</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success and <code>false</code> on failure. </dd></dl>

</div>
</div>
<a id="a35e9ce1b1771a597aa3276ec28de28a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e9ce1b1771a597aa3276ec28de28a7">&#9670;&nbsp;</a></span>SetHandlerMachPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::CrashpadClient::SetHandlerMachPort </td>
          <td>(</td>
          <td class="paramtype">base::mac::ScopedMachSendRight&#160;</td>
          <td class="paramname"><em>exception_port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the process’ crash handler to a Mach port. </p>
<p>This method is only defined on macOS.</p>
<p>See <a class="el" href="classcrashpad_1_1CrashpadClient.html#a810ad9941bedba543bf60507c31c55da" title="Starts a Crashpad handler process, performing any necessary handshake to configure it...">StartHandler()</a> for more detail on how the port and handler are configured.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">exception_port</td><td>An <code>exception_port_t</code> corresponding to a Crashpad exception handler service.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on failure with a message logged. </dd></dl>

</div>
</div>
<a id="a89f34445eca859e6c0d1876e8e171c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f34445eca859e6c0d1876e8e171c25">&#9670;&nbsp;</a></span>SetHandlerMachService()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::CrashpadClient::SetHandlerMachService </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the process’ crash handler to a Mach service registered with the bootstrap server. </p>
<p>This method is only defined on macOS.</p>
<p>See <a class="el" href="classcrashpad_1_1CrashpadClient.html#a810ad9941bedba543bf60507c31c55da" title="Starts a Crashpad handler process, performing any necessary handshake to configure it...">StartHandler()</a> for more detail on how the port and handler are configured.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">service_name</td><td>The service name of a Crashpad exception handler service previously registered with the bootstrap server.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on failure with a message logged. </dd></dl>

</div>
</div>
<a id="a810ad9941bedba543bf60507c31c55da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810ad9941bedba543bf60507c31c55da">&#9670;&nbsp;</a></span>StartHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::CrashpadClient::StartHandler </td>
          <td>(</td>
          <td class="paramtype">const base::FilePath &amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::FilePath &amp;&#160;</td>
          <td class="paramname"><em>database</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const base::FilePath &amp;&#160;</td>
          <td class="paramname"><em>metrics_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>annotations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>restartable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>asynchronous_start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a Crashpad handler process, performing any necessary handshake to configure it. </p>
<p>This method directs crashes to the Crashpad handler. On macOS, this is applicable to this process and all subsequent child processes. On Windows, child processes must also register by using <a class="el" href="classcrashpad_1_1CrashpadClient.html#a9f1d5d38e9b4f5781e3821551dcc39d5" title="Sets the IPC pipe of a presumably-running Crashpad handler process which was started with StartHandle...">SetHandlerIPCPipe()</a>.</p>
<p>On macOS, this method starts a Crashpad handler and obtains a Mach send right corresponding to a receive right held by the handler process. The handler process runs an exception server on this port. This method sets the task’s exception port for <code>EXC_CRASH</code>, <code>EXC_RESOURCE</code>, and <code>EXC_GUARD</code> exceptions to the Mach send right obtained. The handler will be installed with behavior <code>EXCEPTION_STATE_IDENTITY | MACH_EXCEPTION_CODES</code> and thread state flavor <code>MACHINE_THREAD_STATE</code>. Exception ports are inherited, so a Crashpad handler started here will remain the handler for any child processes created after <a class="el" href="classcrashpad_1_1CrashpadClient.html#a810ad9941bedba543bf60507c31c55da" title="Starts a Crashpad handler process, performing any necessary handshake to configure it...">StartHandler()</a> is called. These child processes do not need to call <a class="el" href="classcrashpad_1_1CrashpadClient.html#a810ad9941bedba543bf60507c31c55da" title="Starts a Crashpad handler process, performing any necessary handshake to configure it...">StartHandler()</a> or be aware of Crashpad in any way. The Crashpad handler will receive crashes from child processes that have inherited it as their exception handler even after the process that called <a class="el" href="classcrashpad_1_1CrashpadClient.html#a810ad9941bedba543bf60507c31c55da" title="Starts a Crashpad handler process, performing any necessary handshake to configure it...">StartHandler()</a> exits.</p>
<p>On Windows, if <em>asynchronous_start</em> is <code>true</code>, this function will not directly call <code>CreateProcess()</code>, making it suitable for use in a <code>DllMain()</code>. In that case, the handler is started from a background thread, deferring the handler's startup. Nevertheless, regardless of the value of <em>asynchronous_start</em>, after calling this method, the global unhandled exception filter is set up, and all crashes will be handled by Crashpad. Optionally, use <a class="el" href="classcrashpad_1_1CrashpadClient.html#a0377d4e93ac77453f57f3c1fcae09e14" title="When asynchronous_start is used with StartHandler(), this method can be used to block until the handl...">WaitForHandlerStart()</a> to join with the background thread and retrieve the status of handler startup.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>The path to a Crashpad handler executable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">database</td><td>The path to a Crashpad database. The handler will be started with this path as its <code>--database</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metrics_dir</td><td>The path to an already existing directory where metrics files can be stored. The handler will be started with this path as its <code>--metrics-dir</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">url</td><td>The URL of an upload server. The handler will be started with this URL as its <code>--url</code> argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">annotations</td><td>Process annotations to set in each crash report. The handler will be started with an <code>--annotation</code> argument for each element in this map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arguments</td><td>Additional arguments to pass to the Crashpad handler. Arguments passed in other parameters and arguments required to perform the handshake are the responsibility of this method, and must not be specified in this parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">restartable</td><td>If <code>true</code>, the handler will be restarted if it dies, if this behavior is supported. This option is not available on all platforms, and does not function on all OS versions. If it is not supported, it will be ignored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">asynchronous_start</td><td>If <code>true</code>, the handler will be started from a background thread. Optionally, <a class="el" href="classcrashpad_1_1CrashpadClient.html#a0377d4e93ac77453f57f3c1fcae09e14" title="When asynchronous_start is used with StartHandler(), this method can be used to block until the handl...">WaitForHandlerStart()</a> can be used at a suitable time to retreive the result of background startup. This option is only used on Windows.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on failure with a message logged. </dd></dl>

</div>
</div>
<a id="a1a6a1e62d90a67db782664b1fe5a952f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6a1e62d90a67db782664b1fe5a952f">&#9670;&nbsp;</a></span>UseSystemDefaultHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void crashpad::CrashpadClient::UseSystemDefaultHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configures the process to direct its crashes to the default handler for the operating system. </p>
<p>On macOS, this sets the task’s exception port as in <a class="el" href="classcrashpad_1_1CrashpadClient.html#a35e9ce1b1771a597aa3276ec28de28a7" title="Sets the process’ crash handler to a Mach port. ">SetHandlerMachPort()</a>, but the exception handler used is obtained from <a class="el" href="namespacecrashpad.html#a47204f3a62646651e8f393cac2a6316b" title="Obtains the system’s default Mach exception handler for crash-type exceptions. ">SystemCrashReporterHandler()</a>. If the system’s crash reporter handler cannot be determined or set, the task’s exception ports for crash-type exceptions are cleared.</p>
<p>Use of this function is strongly discouraged.</p>
<dl class="section warning"><dt>Warning</dt><dd>After a call to this function, Crashpad will no longer monitor the process for crashes until a subsequent call to <a class="el" href="classcrashpad_1_1CrashpadClient.html#a35e9ce1b1771a597aa3276ec28de28a7" title="Sets the process’ crash handler to a Mach port. ">SetHandlerMachPort()</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is provided as a static function to allow it to be used in situations where a <a class="el" href="classcrashpad_1_1CrashpadClient.html" title="The primary interface for an application to have Crashpad monitor it for crashes. ...">CrashpadClient</a> object is not otherwise available. This may be useful when a child process inherits its parent’s Crashpad handler, but wants to sever this tie. </dd></dl>

</div>
</div>
<a id="a0377d4e93ac77453f57f3c1fcae09e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0377d4e93ac77453f57f3c1fcae09e14">&#9670;&nbsp;</a></span>WaitForHandlerStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crashpad::CrashpadClient::WaitForHandlerStart </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When <code>asynchronous_start</code> is used with <a class="el" href="classcrashpad_1_1CrashpadClient.html#a810ad9941bedba543bf60507c31c55da" title="Starts a Crashpad handler process, performing any necessary handshake to configure it...">StartHandler()</a>, this method can be used to block until the handler launch has been completed to retrieve status information. </p>
<p>This method should not be used unless <code>asynchronous_start</code> was <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>The number of milliseconds to wait for a result from the background launch, or <code>0xffffffff</code> to block indefinitely.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the hander startup succeeded, <code>false</code> otherwise, and an error message will have been logged. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>client/crashpad_client.h</li>
<li>client/crashpad_client_mac.cc</li>
<li>client/crashpad_client_win.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
